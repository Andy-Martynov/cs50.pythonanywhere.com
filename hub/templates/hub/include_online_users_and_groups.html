{% load static %}

<style>
.groupchat, .groupedit {
    padding: 3px;
    margin: 3px;
    border: 1px solid gray;
    border-radius: 6px;
    background-color: #e6ffe6;
}
.groupedit {
    background-color: #ffe6e6;
}
.group {
    padding: 3px;
    margin: 3px;
    border: 1px solid gray;
    border-radius: 6px;
    background-color: #ffffe6;
}
.message, .mymessage {
    padding: 0px;
    margin: 0px;
}
.message div, .mymessage div {
    max-width: 80%;
    display: inline-block;
    padding: 6px;
    margin: 6px;
    border: 1px solid gray;
    border-radius: 12px;
    background-color: #f2f2f2;
}
.mymessage {
  display: flex;
  flex-flow: row wrap;
  justify-content: flex-end;
}
.mymessage div {
    background-color: #e6f7ff;
    align-self: flex-end;
}
.timestamp {
    text-decoration: underline;
    color: #000080;
    font: 0.75em bold;
}

#userModal section {
    max-height: 50vh;
    overflow: auto;
}
#userModal header {
    max-height: 20vh;
    overflow: auto;
}
#userModalContent {
    max-width: 600px;
}
#user_is_typing {
    height: 1.5em;
}

.blink {
animation: blinker 0.6s linear infinite;
color: #1c87c9;
}
@keyframes blinker {
50% { opacity: 0; }
}
.blink-one {
 animation: blinker-one 1s linear infinite;
}
@keyframes blinker-one {
 0% { opacity: 0; }
}
.blink-two {
 animation: blinker-two 1.4s linear infinite;
}
@keyframes blinker-two {
 100% { opacity: 0; }
}
</style>

<details open>
    <summary>
        <b rus='Кто он-лайн' eng='WHO IS ON-LINE'>WHO IS ON-LINE</b>
    </summary>
    <div id="user_list"></div>
</details>

<details id="GROUPS" class="mt-3" style="display:none;">
    <summary class="my-2">
        <b rus='Группы' eng='GROUPS'>GROUPS</b>
    </summary>
    <details id="my_groups" class="mt-2" open>
        <summary class="ml-2">
            <b rus='Мои группы' eng='MY GROUPS'>MY GROUPS</b>
        </summary>
    </details>
    <details id="groups_im_in" class="mt-2" open>
        <summary class="ml-2">
            <b rus='Я в группах' eng='GROUPS I'M IN'>GROUPS I'M IN</b>
        </summary>
    </details>
</details>

<details id="unreads" class="mt-3" style="display:none;" open>
    <summary class="my-2"><b class="w3-text-red blink" rus='Непрочтенное' eng='.UNREAD'>.UNREAD</b></summary>
</details>

<div id="userModal" class="w3-modal">
    <div id="userModalContent" class="w3-modal-content w3-card-4 w3-animate-zoom w3-round-xlarge">
        <header class="w3-container w3-padding w3-border-bottom w3-border-red">
            <span onclick="{document.getElementById('userModal').style.display='none'; load_unreads();}"
            class="w3-button w3-display-topright w3-xlarge">&times;</span><br>
            <header_content>

            </header_content>
        </header>

        <section class="w3-display-container w3-padding"></section>

        <footer class="w3-container w3-padding">
            <div id="user_is_typing" class="w3-margin"></div>
            <form id="message_form" class="w3-container" action="#" method="post">
                {% csrf_token %}
                <input id="message_to" name="to" value="" hidden readonly>
                <input id="group_id" name="to" value="" hidden readonly>
                {# <input id="message_text" autofocus class="w3-light-gray w3-input w3-margin w3-large w3-round-xlarge" type="text" placeholder="Aa" onchange="sendMessage()"> #}

                <textarea id="message_text" autofocus class="w3-light-gray w3-input w3-margin w3-large w3-round-xlarge" cols="50" rows="2" wrap="hard" onkeypress="ifEnter(event)"></textarea>

                <span class="w3-button w3-teal w3-margin-left w3-round-xlarge" onclick="sendMessage()" rus="отправить" eng="send">send</span>
            </form>
        </footer>
    </div>
</div>

<script>

function ifEnter(event) {
    if (event.key == 'Enter') {
        sendMessage();
    }
}

function displayMessage(el) {
    var msg = document.getElementById("message_"+el.id);
    if (msg == undefined || msg == null) {
        section = document.querySelector('#userModal section');
        dts = el.created.toString();
        dd = parseInt(dts.slice(0, 2));
        mm = parseInt(dts.slice(3, 5)) - 1;
        yy = parseInt(dts.slice(6, 8)) + 2000;
        hh = parseInt(dts.slice(9, 11));
        mn = parseInt(dts.slice(12, 14));
        ss = parseInt(dts.slice(15, 17));
        dt= new Date(Date.UTC(yy, mm, dd, hh, mn, ss, 0));
        now = new Date();
        y = now.getFullYear();
        m = now.getMonth();
        d = now.getDate();

        year = dt.getFullYear() - 2000
        month = dt.getMonth().toString().padStart(2,0);
        date = dt.getDate().toString().padStart(2,0);
        hours = dt.getHours().toString().padStart(2,0);
        minutes = dt.getMinutes().toString().padStart(2,0);

        var stamp = `${year}.${month}.${date} ${hours}:${minutes}`;
        if (y == yy) {
            stamp = `${month}/${date} ${hours}:${minutes}`;
        }
        if (y == yy && mm == m && dd == d) {
            stamp = `${hours}:${minutes}`;
        }
        if (el.sender.id == {{ user.id }}) {
            section.innerHTML += `<div id="message_${el.id}" class="mymessage"><div><i><i class="timestamp">${stamp}</i> ${el.text}</i></div></div>`;
        } else {
            section.innerHTML += `<div id="message_${el.id}" class="message"><img class="avatar" src="${el.sender.image}">  <div><b>${el.sender.username}: </b><i><i class="timestamp">${stamp}</i> ${el.text}</i></div></div>`;
        }
    }
}

async function addMessage(data) {
    // console.log('PUSHER MESSAGE SENT:', data, 'ID:', data.message.sender.id);
    const section = document.querySelector('#userModal section');

    sender_id = data.message.sender.id;
    reciever_id = data.message.reciever.id;
    text = data.message.text;

    uid = document.querySelector('#userModal').getAttribute('uid');
    rid = {{ user.id }};

    if ((sender_id == uid && reciever_id == rid) || (sender_id == rid && reciever_id == uid)) {
        if (sender_id == uid) {
            if (document.getElementById('userModal').style.display == 'block') {
                await fetch(`/chat/clear_sender_unread/{{ user.id }}/${sender_id}`);
                // .then (response => console.log(`clear from group ${sender_id}:`, response));
                unreads = document.querySelectorAll(`#unreads .user[uid="${user_id}"]`);
                // console.log('DELETE:', unreads);
                unreads.forEach(el => el.remove());
            }
        }
        displayMessage(data.message)
    }
    section.scrollTop = section.scrollHeight;
}

async function addGroupMessage(data) {
    // console.log('PUSHER GROUP MESSAGE SENT:', data, 'ID:', data.message.sender.id);
    const section = document.querySelector('#userModal section');

    sender_id = data.message.sender.id;
    reciever_id = data.message.reciever.id;
    text = data.message.text;

    rid = document.querySelector('#group_id').value;

    if (reciever_id == rid) {
        if (document.getElementById('userModal').style.display == 'block') {
            await fetch(`/chat/clear_group_unread/{{ user.id }}/${rid}`);
            // .then (response => console.log(`clear from group ${rid}:`, response));
            unreads = document.querySelectorAll(`#unreads .groupchat[gid="${group_id}"]`);
            // console.log('DELETE:', unreads);
            unreads.forEach(el => el.remove());
        }
        displayMessage(data.message)
    }
    section.scrollTop = section.scrollHeight;
}

async function sendMessage() {
// 	console.log('SEND!', this);
	const to = document.querySelector('#message_to').value;
	const text = document.querySelector('#message_text').value;
	const group_id = document.querySelector('#group_id').value;
    const token = document.querySelector('[name="csrfmiddlewaretoken"]').value;

	if (group_id == "") {
	    let post = {
    	    csrfmiddlewaretoken: token,
    		to: to,
    		text: text
    	};
    	let response = await fetch('/chat/message', {
    		method: 'POST',
    	    headers: {
            'Content-Type': 'application/json;charset=utf-8'
    		},
    		body: JSON.stringify(post)
    	});
    // 	console.log('MESSAGE response: ', response);
	} else {
    // 	console.log(`--- SEND GROUP --- <${group_id}>`);
    	let post = {
    	    csrfmiddlewaretoken: token,
    		to: group_id,
    		text: text
    	};
    	let response = await fetch('/chat/group_message', {
    		method: 'POST',
    	    headers: {
            'Content-Type': 'application/json;charset=utf-8'
    		},
    		body: JSON.stringify(post)
    	});
	}
	document.querySelector('#message_text').value = "";
}

init();

async function init() {
    await load_users();
    await console.log("------------ users loaded ----------------");

    await load_groups({{ user.id }});
    await console.log("------------ groups loaded ----------------");

    await load_unreads();
    await console.log("------------ unreads loaded ----------------");

    let users = document.querySelectorAll('.user');
    let groups = document.querySelectorAll('.groupchat');

    await addModalListeners();

    Pusher.logToConsole = false;
    var pusher = new Pusher('bbe70803665a7a964619', {
      cluster: 'eu',
      authEndpoint: '/pusher/auth',
    });

    var channel = pusher.subscribe('private-my-channel');
    channel.bind('sent-to-user', handleSent);

    const beamsClient = new PusherPushNotifications.Client({
        instanceId: '4db9511e-c5da-4d6f-8f58-9fbee669a07f',
    });

    await beamsClient.start()
        .then(() => beamsClient.addDeviceInterest('hello'))
        .then(() => console.log('Successfully registered and subscribed!'))
        .catch(console.error);

    beamsClient.start()
        .then(beamsClient => beamsClient.getDeviceId())
        .then(deviceId =>
          console.log('Successfully registered with Beams. Device ID:', deviceId)
        )
        .then(() => beamsClient.addDeviceInterest('hello'))
        .then(() => beamsClient.getDeviceInterests())
        .then(interests => console.log('Current interests:', interests))
        .catch(console.error);

    const tokenProvider = new PusherPushNotifications.TokenProvider({
        url: 'https://cs50.pythonanywhere.com/pusher/beams-auth',
        queryParams: { userId: '{{ user.id }}' },
        headers: { 'Header': 'cs50' },
        credentials: 'include',
    });

    console.log('tokenProvider', tokenProvider);

    await beamsClient.start()
      .then(() => beamsClient.setUserId('{{ user.id }}', tokenProvider))
      .then(() => console.log('User ID has been set'))
      .catch(e => console.error('Could not authenticate with Beams:', e));

    const currentUserId = '{{ user.id }}' // Get this from your auth system

    await beamsClient.getUserId()
      .then(userId => {
        // Check if the Beams user matches the user that is currently logged in
        if (userId !== currentUserId) {
            // Unregister for notifications
            return beamsClient.stop();
            console.log(`********** STOP ${userId} / ${currentUserId}`)
        } else {
            console.log(`********** USER OK ${userId} / ${currentUserId}`)
        }
      })
      .catch(console.error);

    {% if user.is_superuser %}
        bell = document.querySelector('#user_message');
        bell.addEventListener('click', ringBell);
    {% endif %}

    redbell = document.querySelector('#beam_hello');
    redbell.addEventListener('click', ringRedBell);
    greenbell = document.querySelector('#message_hello');
    greenbell.addEventListener('click', ringGreenBell);

    beamsClient.getRegistrationState()
        .then(state => {
        let states = PusherPushNotifications.RegistrationState
        switch(state) {
          case states.PERMISSION_DENIED: {
              console.log("-----------------Notifications are blocked");
            // Notifications are blocked
            // Show message saying user should unblock notifications in their browser
            break
          }
          case states.PERMISSION_GRANTED_REGISTERED_WITH_BEAMS: {
              console.log("-----------------Ready to receive notifications");
            // Ready to receive notifications
            // Show "Disable notifications" button, onclick calls '.stop'
            break
          }
          case states.PERMISSION_GRANTED_NOT_REGISTERED_WITH_BEAMS:
          case states.PERMISSION_PROMPT_REQUIRED: {
              console.log("--------------------Need to call start before we're ready to receive notifications");
            // Need to call start before we're ready to receive notifications
            // Show "Enable notifications" button, onclick calls '.start'
            break
          }
        }
        })
        .catch(e => console.error('Could not get registration state', e))

    beamsClient.getUserId()
        .then(userId => {
        console.log(`=========== UDER ID : <${userId}>`, typeof userId) // Will log the current user id
        })
        .catch(e => console.error('Could not get user id', e));
}

async function ringBell() {
    console.log('%%%%%%%%%%%%%%%% BELL %%%%%%%%%%%%%%%%');
    response = await fetch(`/beam_user_message/1`)
    .then (response => response.json());
    console.log("RESPONSE: ", response);
}
async function ringRedBell() {
    console.log('%%%%%%%%%%%%%%%% RED BELL %%%%%%%%%%%%%%%%');
    let text = prompt("Push notification for all / Уведомление всем");
    if (text != null && text != '') {
        response = await fetch(`/beam_hello/${text}`)
        .then (response => response.json());
        console.log("RESPONSE: ", response);
    }
}
async function ringGreenBell() {
    console.log('%%%%%%%%%%%%%%%% GREEN BELL %%%%%%%%%%%%%%%%');
    let text = prompt("Message for all on-line/ Сообщение всем, кто сейчас на сайте");
    if (text != null && text != '') {
        response = await fetch(`/hello/${text}`)
        .then (response => response.json());
        console.log("RESPONSE: ", response);
    }
}

function load_users() {
    Pusher.logToConsole = true;
    var pusher = new Pusher('bbe70803665a7a964619', {
      cluster: 'eu',
      authEndpoint: '/pusher/auth',
    });
    const presence_channel = pusher.subscribe('presence-my-channel');

    function addMemberToUserList(memberId, info) {
        var e = document.getElementById("online_user_"+memberId);
        // console.log(e, info);
        if (info != undefined) {
            if (typeof e == "undefined" || e == null) {
                userEl = document.createElement("div");
                userEl.className = 'user m-1 p-1';
                userEl.id = "online_user_"+memberId;
                userEl.innerHTML = `<img src="${info.image}" class="avatar"> <span class="username">${info.username}</span>`;
                document.getElementById("user_list").appendChild(userEl);
                userEl.addEventListener('click', userModalSetup);
                userEl.setAttribute('uid', memberId);
                onlines = document.querySelectorAll(`.online_${memberId}`);
                // console.log('ON-Lines:', onlines);
                onlines.forEach(el => el.style.display='inline');
            }
        }
    }

    presence_channel.bind('pusher:subscription_succeeded', () =>
        presence_channel.members.each(member => {addMemberToUserList(member.id, member.info); } ));
    presence_channel.bind('pusher:member_added', member => {addMemberToUserList(member.id, member.info); console.log('added:', member);});
    presence_channel.bind('pusher:member_removed', member => {
        // console.log('removed:', member);
        const userEl = document.getElementById("online_user_"+member.id);
        userEl.parentNode.removeChild(userEl);
    });
}

function formatName(name) {
    return name.replace('_', ' ');
}

function createUserEl(u, tag="div") {
    userEl = document.createElement(tag);
    userEl.className = 'user m-1 p-1';
    userEl.id = "user_" + u.id;
    userEl.setAttribute('uid', u.id);

    let online = ` <i class="fa fa-circle online_${u.id}" style="color:#00ff00; display:none;"></i>`;

    if (u.image != null) {
        userEl.innerHTML = `<img src="${u.image}" class="avatar"> <span class="username">${u.username}</span> ${online}`;
    } else {
        userEl.innerHTML = `<img src="{% static 'account/x.png' %}" class="avatar"> <span class="username">${u.username}</span> ${online}`;
    }
    return userEl;
}

function displayMembers(members, place, tag="div") {
    if (typeof members != "undefined") {
        for (var j =0; j < members.length; j++) {
            userEl = createUserEl(members[j], tag=tag);
            place.appendChild(userEl);
        }
    }
}

function displayGroups(groups, groups_place) {
    if (typeof groups != "undefined") {
        document.getElementById("GROUPS").style.display = "block";
        for (var i =0; i < groups.length; i++) {
            groupEl = document.createElement("details");
            groupEl.innerHTML = `<summary>${groups[i].name} by ${groups[i].creator.username}</summary>`;
            if (groups[i].creator.id == {{ user.id }}) {
                groupEl.innerHTML += `<div class="groupedit" gid="${groups[i].id}"><a href="account/group_update/${groups[i].id}"><i class="fa fa-edit"></i> UPDATE GROUP</a></div>`;
            }
            groupEl.innerHTML += `<div class="groupchat" gid="${groups[i].id}"><img src="{% static 'chat/chat_32.png' %}"> GROUP CHAT</div>`;
            groupEl.id = `my_${groups[i].id}`;
            groupEl.className = 'ml-3 group';
            groups_place.appendChild(groupEl);

            displayMembers(groups[i].members, document.getElementById(`my_${groups[i].id}`));
        }
    }
}

async function load_groups(user_id) {
    // console.log('LOAD GROUPS');
    info = await fetch(`/account/user_info/${user_id}`)
    .then (response => response.json());

    // console.log('INFO:', info)

    const my_groups = info.my_groups;
    const my_groups_place = document.getElementById("my_groups");
    displayGroups(my_groups, my_groups_place);

    const groups_im_in = info.groups_im_in;
    const groups_im_in_place = document.getElementById("groups_im_in");
    displayGroups(groups_im_in, groups_im_in_place);
}

function  handleSent(data) {
    // console.log("handleSent:", data);
    if (data.user == {{ user.id }}) {
        load_unreads();
    }
}

var timerId;
var TITLETEXT = document.querySelector('title').text;

async function load_unreads() {
    // console.log('LOAD UNREADS');
    unreads = await fetch(`/chat/unread_list`)
    .then (response => response.json());

    // console.log('=== UnReads:', unreads);

    unreads_place = document.getElementById("unreads");
    unreads_place.style.display = "none";
    clearInterval(timerId);

    unreads_place.innerHTML = `<summary class="my-2"><b class="w3-text-red blink" rus="Непрочтенное" eng="UNREAD">UNREAD</b></summary>`;

    const title = document.querySelector('title');
    title.text = TITLETEXT;

    if (typeof unreads != "undefined" && unreads.length > 0) {
        unreads_place = document.getElementById("unreads");
        unreads_place.style.display = "block";

        timerId = setInterval(() => blinkMessage(), 1000);

        for (var i =0; i < unreads.length; i++) {
            // e = document.createElement("div");
            if (unreads[i].mode == 'group') {
                unreads_place.innerHTML += `<div class="groupchat" gid="${unreads[i].group.id}"><img src="{% static 'chat/chat_32.png' %}"> ${unreads[i].group.name}</div>`;
            } else {
                userEl = createUserEl(unreads[i].sender, tag="div");
                unreads_place.appendChild(userEl);
            }
        }
    }
    addModalListeners();
}

function blinkMessage() {
    // console.log('Blink');
    const title = document.querySelector('title');
    if (title.text == TITLETEXT) {
        title.text = 'MESSAGE';
    } else {
        title.text = TITLETEXT;
    }
}

async function userModalSetup() {
    id = this.id;
    user_id = this.getAttribute('uid');

    await fetch(`/chat/clear_sender_unread/{{ user.id }}/${user_id}`);
    // .then (response => console.log(`clear from sender ${user_id}:`, response));
    unreads = document.querySelectorAll(`#unreads .user[uid="${user_id}"]`);
    unreads.forEach(el => el.remove());

    info = await fetch(`/chat/message_list/${user_id}/{{ user.id }}`)
    .then (response => response.json());

    username = document.querySelector(`#${id} span`).innerText;
    image = document.querySelector(`#${id} img`).getAttribute('src');
    modal = document.querySelector('#userModal');
    modal.setAttribute('uid', user_id);
    modal.setAttribute('mode', 'user');
    modal.style.display = 'block';
    header = document.querySelector('#userModal header_content');
    section = document.querySelector('#userModal section');
    footer = document.querySelector('#userModal footer');

    header.innerHTML = `<img class="avatar" src="${image}"> <span class="username">${username}</span>`;

    section.innerHTML = "";
    info.forEach(el => displayMessage(el));

    section.scrollTop = section.scrollHeight;

    document.querySelector('#message_to').value = user_id;
    document.querySelector('#group_id').value = "";

    Pusher.logToConsole = true;
    var pusher = new Pusher('bbe70803665a7a964619', {
      cluster: 'eu',
      authEndpoint: '/pusher/auth',
    });
    var channel = pusher.subscribe('private-my-channel');
    channel.bind('message-sent', addMessage);
    channel.bind('typing', somebodyTyping);
}

async function groupModalSetup() {
    // console.log("groupModalSetup", this);

    id = this.id;
    group_id = this.getAttribute('gid');
    // groupname = document.querySelector(`#${id} summary`).innerText;

    await fetch(`/chat/clear_group_unread/{{ user.id }}/${group_id}`);
    // .then (response => console.log(`clear from group ${group_id}:`, response));
    unreads = document.querySelectorAll(`#unreads .groupchat[gid="${group_id}"]`);
    unreads.forEach(el => el.remove());

    info = await fetch(`/account/group_info/${group_id}`)
    .then (response => response.json());

    modal = document.querySelector('#userModal');
    modal.setAttribute('mode', 'group');
    modal.setAttribute('gid', group_id);
    modal.style.display = 'block';
    header = document.querySelector('#userModal header_content');
    section = document.querySelector('#userModal section');
    footer = document.querySelector('#userModal footer');

    header.innerHTML = `<h5 class="w3-text-blue">${info.groupname}</h5>`;
    header.innerHTML += '<div id="group_members" class="w3-padding"></div>';
    group_members = document.querySelector('#group_members');
    document.querySelector('#group_id').value = group_id;
    displayMembers(info.members, group_members, tag="span");

    info = await fetch(`/chat/group_message_list/${group_id}`)
    .then (response => response.json());

    section.innerHTML = "";
    info.forEach(el => displayMessage(el));

    section.scrollTop = section.scrollHeight;

    document.querySelector('#group_id').value = group_id;

    Pusher.logToConsole = true;
    var pusher = new Pusher('bbe70803665a7a964619', {
      cluster: 'eu',
      authEndpoint: '/pusher/auth',
    });
    var channel = pusher.subscribe('private-my-channel');
    channel.bind('group-message-sent', addGroupMessage);
    channel.bind('typing', somebodyTyping);
}

function somebodyTyping(data) {
    var clearInterval = 1900; //1.9 seconds
    var clearTimerId;

    // console.log('~~~ Typing ~~~', data.from.username, data.mode, data.to);

    user_is_typing = document.querySelector('#user_is_typing');

    const mode = document.querySelector('#userModal').getAttribute('mode');
    const user_id = {{ user.id }};
    if (mode == 'user') {
        // id = document.querySelector('#userModal').getAttribute('uid');
        id = {{ user.id }};
    } else {
        id = document.querySelector('#userModal').getAttribute('gid');
    }

    // console.log(user_is_typing, 'data.to:', data.to, 'id:', id, 'data.from.id:', data.from.id, 'user.id:', {{ user.id }});

    if(data.to == id && data.from.id != {{ user.id }}) {
        user_is_typing.innerHTML = `<img src="${data.from.image}" class="avatar"> <span class="username">${data.from.username}</span> <i class="fa fa-spinner fa-spin"></i>`;
        //restart timeout timer
        clearTimeout(clearTimerId);
        clearTimerId = setTimeout(function () {
            //clear user is typing message
            user_is_typing.innerHTML = '';
        }, clearInterval);
    }
}

canPublish = true;

function userIsTyping() {
    var trottleTime = 1000; // 1 sec

    // console.log('TypIng .....')

    uid = document.querySelector('#userModal').getAttribute('uid');
    const mode = document.querySelector('#userModal').getAttribute('mode');
    const user_id = {{ user.id }};
    if (mode == 'user') {
        id = document.querySelector('#userModal').getAttribute('uid');
    } else {
        id = document.querySelector('#userModal').getAttribute('gid');
    }
    if (canPublish) {
        // console.log('-- TYPING --', user_id, mode, id);
        info = fetch(`/chat/typing/${user_id}/${mode}/${id}`);
        // .then (response => response.json());
        canPublish = false;
        setTimeout(function () { canPublish = true;}, trottleTime)
    }
}

function addModalListeners() {
    let users = document.querySelectorAll('.user');
    // console.log('USERS:', users);
    users.forEach(el => el.addEventListener('click', userModalSetup));

    let groups = document.querySelectorAll('.groupchat');
    // console.log('GROUP :', groups);
    groups.forEach(el => el.addEventListener('click', groupModalSetup));

    let message_text = document.querySelector('#message_text');
    // console.log('message_text :', message_text);
    message_text.addEventListener('keyup', userIsTyping);
}
</script>


